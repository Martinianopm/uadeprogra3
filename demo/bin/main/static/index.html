<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Maze Web</title>
  <style>
    body{font-family:system-ui,Arial,Helvetica; margin:16px; background:#0b0f14; color:#e6edf3;}
    .row{display:flex; gap:8px; align-items:center; margin-bottom:10px; flex-wrap:wrap}
    button{padding:8px 12px; border-radius:10px; border:1px solid #2c3847; background:#141b23; color:#e6edf3; cursor:pointer}
    input[type=number]{width:80px; padding:6px 8px; border-radius:8px; border:1px solid #2c3847; background:#0f141a; color:#e6edf3}
    #mazeId{min-width:360px; padding:6px 8px; border-radius:8px; border:1px solid #2c3847; background:#0f141a; color:#9fb3c8}
    #log{white-space:pre-line; font-size:12px; color:#9fb3c8; margin-top:8px}
    canvas{background:#0f141a; border:1px solid #2c3847; border-radius:12px; image-rendering:pixelated}
    .pill{padding:4px 8px; background:#18202a; border:1px solid #2c3847; border-radius:999px; font-size:12px}
  </style>
</head>
<body>
  <h2>Generador & Juego de Laberinto (Java + Neo4j)</h2>

  <div class="row">
    <label>Filas <input id="rows" type="number" value="15" min="5" max="100"></label>
    <label>Columnas <input id="cols" type="number" value="20" min="5" max="100"></label>
    <label>MÃ©todo 
      <select id="method">
        <option value="dfs">DFS</option>
        <option value="prim">Prim</option>
        <option value="kruskal">Kruskal</option>
      </select>
    </label>
    <label><input type="checkbox" id="weighted"> Weighted</label>
    <button id="btnGen">Generar</button>
    <span class="pill">Start: (0,0)</span>
    <span class="pill">Goal: (rows-1, cols-1)</span>
  </div>

  <div class="row">
    <input id="mazeId" placeholder="mazeId (se completa al generar)"/>
    <button id="btnLoad">Cargar</button>
    <button id="btnSolveBfs">Resolver (BFS)</button>
    <button id="btnSolveDij">Resolver (Dijkstra)</button>
    <button id="btnReset">Reset jugador</button>
  </div>

  <canvas id="cv" width="900" height="600"></canvas>
  <div id="log"></div>

<script>
const $ = (sel)=>document.querySelector(sel);
const API = ""; // mismo host

let state = {
  mazeId: null,
  rows: 0, cols: 0,
  edges: [],
  h: [], v: [],
  r: 0, c: 0,
  goalR: 0, goalC: 0,
  cellSize: 28,
  margin: 20,
};

function log(msg){ $("#log").textContent = msg; }

async function postJson(url, body){
  const res = await fetch(url, {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify(body)
  });
  if(!res.ok) throw new Error(await res.text());
  return await res.json();
}
async function getJson(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error(await res.text());
  return await res.json();
}

$("#btnGen").onclick = async ()=>{
  try{
    const rows = +$("#rows").value|0, cols= +$("#cols").value|0;
    const method = $("#method").value;
    const weighted = $("#weighted").checked;
    log("Generando con "+method+"...");
    const g = await postJson(API+"/maze/generate", {rows, cols, method, weighted});
    state.mazeId = g.mazeId;
    $("#mazeId").value = state.mazeId;
    await loadMaze();
    resetPlayer();
    draw();
    log("Listo. MazeId: "+state.mazeId+" ("+method+")");
  }catch(e){ log("Error: "+e.message); console.error(e); }
};

$("#btnLoad").onclick = async ()=>{
  try{
    state.mazeId = $("#mazeId").value.trim();
    await loadMaze();
    resetPlayer();
    draw();
    log("Cargado: "+state.mazeId);
  }catch(e){ log("Error: "+e.message); }
};

$("#btnSolveBfs").onclick = ()=>solve("bfs");
$("#btnSolveDij").onclick = ()=>solve("dijkstra");

async function solve(algo){
  if(!state.mazeId) return log("GenerÃ¡ o cargÃ¡ un maze primero.");
  try{
    const s = {r:0, c:0};
    const t = {r:state.rows-1, c:state.cols-1};
    const ans = await postJson(API+"/maze/solve", {mazeId: state.mazeId, start:s, end:t, algo});
    log(algo.toUpperCase()+": length="+ans.length+" visited="+ans.visited+" cost="+ans.cost);
    await animatePath(ans.path);
  }catch(e){ log("Error: "+e.message); }
}

$("#btnReset").onclick = ()=>{ resetPlayer(); draw(); };

document.addEventListener("keydown", (ev)=>{
  const k = ev.key;
  let {r,c} = state;
  if(k==="ArrowUp")   tryMove(r-1,c);
  if(k==="ArrowDown") tryMove(r+1,c);
  if(k==="ArrowLeft") tryMove(r,c-1);
  if(k==="ArrowRight")tryMove(r,c+1);
});

async function loadMaze(){
  const m = await getJson(API+"/maze/"+state.mazeId);
  state.rows = m.rows; state.cols = m.cols; state.edges = m.edges;
  state.goalR = state.rows-1; state.goalC = state.cols-1;
  buildWalls();
  autosizeCanvas();
}

function buildWalls(){
  const R=state.rows, C=state.cols;
  state.h = Array.from({length:R+1}, ()=>Array(C).fill(true));
  state.v = Array.from({length:R}, ()=>Array(C+1).fill(true));
  for(const e of state.edges){
    const {r1,c1,r2,c2} = e;
    if(r2 === r1+1 && c2 === c1){ state.h[r2][c1] = false; }
    else if(r2 === r1-1 && c2 === c1){ state.h[r1][c1] = false; }
    else if(c2 === c1+1 && r2 === r1){ state.v[r1][c2] = false; }
    else if(c2 === c1-1 && r2 === r1){ state.v[r1][c1] = false; }
  }
  state.h[0][0] = false;
  state.h[R][C-1] = false;
}

function autosizeCanvas(){
  const cv = $("#cv");
  const maxW = 980, maxH = 640;
  const cell = Math.max(12, Math.min(
    Math.floor((maxW-2*state.margin)/state.cols),
    Math.floor((maxH-2*state.margin)/state.rows)
  ));
  state.cellSize = cell;
  cv.width = state.margin*2 + state.cols*cell;
  cv.height= state.margin*2 + state.rows*cell;
}

function draw(){
  const cv = $("#cv"), ctx = cv.getContext("2d");
  const S = state.cellSize, M = state.margin;

  ctx.fillStyle = "#0f141a";
  ctx.fillRect(0,0,cv.width,cv.height);

  ctx.strokeStyle = "#9fb3c8";
  ctx.lineWidth = 3;
  for(let r=0;r<=state.rows;r++){
    for(let c=0;c<state.cols;c++){
      if(state.h[r][c]){
        const x1=M+c*S, y1=M+r*S, x2=M+(c+1)*S;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y1); ctx.stroke();
      }
    }
  }
  for(let r=0;r<state.rows;r++){
    for(let c=0;c<=state.cols;c++){
      if(state.v[r][c]){
        const x1=M+c*S, y1=M+r*S, y2=M+(r+1)*S;
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x1,y2); ctx.stroke();
      }
    }
  }

  ctx.fillStyle = "#2ecc71";
  ctx.fillRect(M + state.goalC*S + S*0.25, M + state.goalR*S + S*0.25, S*0.5, S*0.5);

  ctx.fillStyle = "#e67e22";
  ctx.beginPath();
  ctx.arc(M + state.c*S + S/2, M + state.r*S + S/2, S*0.35, 0, Math.PI*2);
  ctx.fill();
}

function resetPlayer(){ state.r=0; state.c=0; }

function canMove(r,c,nr,nc){
  if(nr<0||nr>=state.rows||nc<0||nc>=state.cols) return false;
  if(nr===r-1 && nc===c) return !state.h[r][c];
  if(nr===r+1 && nc===c) return !state.h[nr][nc];
  if(nr===r && nc===c-1) return !state.v[r][c];
  if(nr===r && nc===c+1) return !state.v[r][nc];
  return false;
}

function tryMove(nr,nc){
  if(canMove(state.r,state.c,nr,nc)){
    state.r=nr; state.c=nc; draw();
    if(nr===state.goalR && nc===state.goalC) log("ðŸŽ‰ Â¡Ganaste!");
  }
}

async function animatePath(path){
  if(!Array.isArray(path) || !path.length) return;
  for(const p of path){
    state.r = p.r; state.c = p.c;
    draw();
    await new Promise(r=>setTimeout(r, 25));
  }
}
</script>
</body>
</html>
